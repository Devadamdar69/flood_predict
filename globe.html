<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Globe — Focus India (Full-screen Image)</title>
<style>
  /* base layout */
  html,body{height:100%;margin:0;background:#000;overflow:hidden;font-family:Inter,Arial,Helvetica}
  #container{position:relative;width:100vw;height:100vh;overflow:hidden}

  /* starfield canvas behind everything */
  #stars { position:absolute; inset:0; z-index:0; display:block; width:100%; height:100%; background:#000; }

  /* three.js canvas container */
  #globe-root { position:absolute; inset:0; z-index:1; }

  /* subtle vignette */
  .vignette { position:absolute; inset:0; z-index:8; pointer-events:none;
    background: radial-gradient(ellipse at center, rgba(0,0,0,0) 45%, rgba(0,0,0,0.18) 70%, rgba(0,0,0,0.6) 100%); }

  /* caption */
  .caption{position:absolute; z-index:20; left:50%; bottom:22px; transform:translateX(-50%); color:#a9d2ff; font-weight:600; text-shadow:0 8px 22px rgba(0,0,0,0.6)}

  /* FULL-SCREEN India overlay */
  .india-overlay{
    position:fixed; /* fixed so it truly fills viewport */
    inset:0;
    z-index:40;              /* high so it fully covers globe + stars */
    display:flex;
    align-items:center;
    justify-content:center;
    pointer-events:none;
    opacity:0;
    transform:scale(0.995);
    transition: opacity 700ms ease, transform 700ms cubic-bezier(.22,.9,.33,1);
    background: rgba(0,0,0,0.0); /* allow image to show; set to rgba black if you want darker fade */
  }
  .india-overlay.visible{
    opacity:1;
    transform:scale(1);
    background: rgba(0,0,0,0.0);
  }

  /* make image truly fullscreen and cover while preserving aspect ratio */
  .india-img{
    position:absolute;
    inset:0;
    width:100%;
    height:100%;
    object-fit:cover;
    object-position:center center;
    display:block;
    will-change: transform, opacity;
    transition: transform 700ms cubic-bezier(.22,.9,.33,1), opacity 700ms ease;
    opacity:0;
  }
  .india-overlay.visible .india-img{
    opacity:1;
    transform: scale(1);
  }

  /* loader text */
  .loader{position:absolute; z-index:45; left:50%; top:50%; transform:translate(-50%,-50%); color:#8fb6df; font-weight:600}
  @media(max-width:560px){ .caption{font-size:13px} }
</style>
</head>
<body>
  <div id="container">
    <!-- starfield canvas -->
    <canvas id="stars" aria-hidden="true"></canvas>

    <!-- three.js will append canvas here -->
    <div id="globe-root" aria-hidden="true"></div>

    <div class="vignette" aria-hidden="true"></div>

    <div class="caption" id="caption">Preparing globe…</div>

    <!-- FULL-SCREEN overlay (updated image) -->
    <!-- NOTE: filename contains spaces — encoded as %20 in the src below. If you rename the file, update src accordingly. -->
    <div id="indiaOverlay" class="india-overlay" aria-hidden="true">
      <img id="indiaImg" class="india-img" src="india.png" alt="India — full screen"/>
    </div>

    <div id="loader" class="loader">Loading texture…</div>
  </div>

  <!-- three.js -->
  <script src="https://unpkg.com/three@0.152.0/build/three.min.js"></script>
  <script>
  (function(){
    /* ---------- STARFIELD ---------- */
    const starCanvas = document.getElementById('stars');
    const sctx = starCanvas.getContext('2d');
    let S_WIDTH = 0, S_HEIGHT = 0;
    const STAR_COUNT = 260;
    const stars = [];

    function resizeStars(){
      const dpr = Math.min(2, window.devicePixelRatio || 1);
      S_WIDTH = starCanvas.clientWidth = window.innerWidth;
      S_HEIGHT = starCanvas.clientHeight = window.innerHeight;
      starCanvas.width = S_WIDTH * dpr;
      starCanvas.height = S_HEIGHT * dpr;
      sctx.setTransform(dpr,0,0,dpr,0,0);
      sctx.globalCompositeOperation = 'lighter';
      stars.length = 0;
      for (let i=0;i<STAR_COUNT;i++){
        stars.push({
          x: Math.random()*S_WIDTH,
          y: Math.random()*S_HEIGHT,
          r: (Math.random()*1.15)+0.2,
          base: Math.random()*0.9 + 0.1,
          speed: 0.5 + Math.random()*1.8,
          phase: Math.random()*Math.PI*2,
          twinkle: Math.random()*0.9 + 0.1
        });
      }
    }

    function drawStars(time){
      sctx.clearRect(0,0,S_WIDTH,S_HEIGHT);
      const bandGrad = sctx.createLinearGradient(0, S_HEIGHT*0.2, 0, S_HEIGHT*0.8);
      bandGrad.addColorStop(0, 'rgba(255,255,255,0.00)');
      bandGrad.addColorStop(0.5, 'rgba(30,90,140,0.03)');
      bandGrad.addColorStop(1, 'rgba(0,0,0,0)');
      sctx.fillStyle = bandGrad;
      sctx.fillRect(0,0,S_WIDTH,S_HEIGHT);

      for (let i=0;i<stars.length;i++){
        const st = stars[i];
        const alpha = Math.max(0, st.base + Math.sin((time*0.001*st.speed) + st.phase) * 0.45 * st.twinkle);
        sctx.beginPath();
        const g = sctx.createRadialGradient(st.x, st.y, 0, st.x, st.y, st.r*6);
        g.addColorStop(0, `rgba(160,220,255,${0.25*alpha})`);
        g.addColorStop(0.5, `rgba(160,220,255,${0.06*alpha})`);
        g.addColorStop(1, `rgba(160,220,255,0)`);
        sctx.fillStyle = g;
        sctx.fillRect(st.x - st.r*6, st.y - st.r*6, st.r*12, st.r*12);
        sctx.beginPath();
        sctx.fillStyle = `rgba(220,245,255,${0.9*alpha})`;
        sctx.arc(st.x, st.y, st.r, 0, Math.PI*2);
        sctx.fill();
      }
    }

    /* ---------- THREE.JS GLOBE ---------- */
    const ROOT = document.getElementById('globe-root');
    const caption = document.getElementById('caption');
    const loaderEl = document.getElementById('loader');
    const indiaOverlay = document.getElementById('indiaOverlay');
    const indiaImg = document.getElementById('indiaImg');

    let scene, camera, renderer, globeMesh, animationId;
    let width = window.innerWidth, height = window.innerHeight;
    const INDIA = { lat: 22.9734, lon: 78.6569 };

    function latLonToTargetRotation(lat, lon){
      const latRad = lat * Math.PI / 180;
      const lonRad = lon * Math.PI / 180;
      return { x: latRad * 0.5, y: -lonRad };
    }

    function initThree(){
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(40, width/height, 0.1, 1000);
      camera.position.set(0,0,3.2);

      renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
      renderer.setClearColor(0x000000, 0); // transparent so star background shows
      renderer.setSize(width, height);
      renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));
      ROOT.appendChild(renderer.domElement);

      const hemi = new THREE.HemisphereLight(0xffffff, 0x04051a, 0.9); scene.add(hemi);
      const dir = new THREE.DirectionalLight(0xffffff, 0.6); dir.position.set(5,3,5); scene.add(dir);
    }

    function attemptTextureLoad(){
      const loader = new THREE.TextureLoader();
      const local = 'earth.jpg';
      const fallback = 'https://raw.githubusercontent.com/joe-robertson/planet-textures/master/2_no_clouds_4k.jpg';

      loader.load(local,
        (tex) => { loaderEl.style.display='none'; createGlobe(tex); console.log('Loaded local earth.jpg'); },
        undefined,
        (errLocal) => {
          console.warn('Local earth.jpg not found. Trying hosted fallback.', errLocal);
          caption.textContent = 'Local texture not found — fetching fallback…';
          loader.load(fallback,
            (tex2) => { loaderEl.style.display='none'; createGlobe(tex2); console.log('Loaded hosted fallback'); },
            undefined,
            (errRemote) => {
              console.warn('Hosted fallback failed. Using procedural texture.', errRemote);
              caption.textContent = 'Texture unavailable — using procedural fallback.';
              const proc = createProceduralTexture(2048,1024);
              loaderEl.style.display='none';
              createGlobe(proc);
            }
          );
        }
      );
    }

    function createGlobe(textureOrCanvas){
      let texture = textureOrCanvas;
      if (textureOrCanvas instanceof HTMLCanvasElement){
        texture = new THREE.CanvasTexture(textureOrCanvas);
      }
      if (texture && renderer.capabilities && renderer.capabilities.getMaxAnisotropy){
        texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
      }
      const material = new THREE.MeshPhongMaterial({ map: texture, shininess: 5 });
      globeMesh = new THREE.Mesh(new THREE.SphereGeometry(1, 64, 64), material);
      scene.add(globeMesh);
      caption.textContent = 'Globe ready — rotating…';
      startRotationPhase();
    }

    function createProceduralTexture(w=2048,h=1024){
      const c = document.createElement('canvas'); c.width=w; c.height=h;
      const ctx = c.getContext('2d');
      const g = ctx.createLinearGradient(0,0,0,h); g.addColorStop(0, '#0b3b6f'); g.addColorStop(1, '#05283d');
      ctx.fillStyle = g; ctx.fillRect(0,0,w,h);
      for (let i=0;i<10000;i++){ ctx.fillStyle = 'rgba(255,255,255,' + (Math.random()*0.02) + ')'; ctx.fillRect(Math.random()*w, Math.random()*h, 1, 1); }
      ctx.fillStyle = '#cfc098'; ctx.globalAlpha=0.98;
      drawBlob(ctx,w*0.55,h*0.33,420,180,0.65); drawBlob(ctx,w*0.5,h*0.45,260,140,0.6);
      drawBlob(ctx,w*0.23,h*0.58,200,260,0.6); drawBlob(ctx,w*0.77,h*0.68,140,90,0.7); drawBlob(ctx,w*0.615,h*0.415,90,70,0.95);
      ctx.globalAlpha = 1.0; return c;
    }
    function drawBlob(ctx,cx,cy,rx,ry,ir){ ctx.beginPath(); const steps=18; for(let i=0;i<=steps;i++){ const t=(i/steps)*Math.PI*2; const r=1-(ir*(0.2+Math.random()*0.6)); const x=cx+Math.cos(t)*rx*r; const y=cy+Math.sin(t)*ry*r; if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);} ctx.closePath(); ctx.fill(); }

    /* animation phases */
    let phase=0; let autoRotateSpeed=0.006; let rotationDamping=0.998;
    let focusStart=null, focusDuration=2100, startRot={x:0,y:0}, targetRot={x:0,y:0};
    let zoomStart=null, zoomDuration=1600, startCamZ=3.2, targetCamZ=1.28;

    function startRotationPhase(){ phase=0; setTimeout(()=>{ phase=1; beginFocusToIndia(); }, 2200); }
    function beginFocusToIndia(){
      if(!globeMesh) return;
      startRot.x = globeMesh.rotation.x; startRot.y = globeMesh.rotation.y;
      const t = latLonToTargetRotation(INDIA.lat, INDIA.lon);
      targetRot.x = t.x * 0.85; targetRot.y = t.y;
      focusStart = performance.now(); phase = 1;
      setTimeout(()=>{ phase = 2; startZoomToIndia(); }, focusDuration + 80);
    }
    function startZoomToIndia(){ zoomStart = performance.now(); startCamZ = camera.position.z; phase = 2;
      setTimeout(()=>{ phase = 3; caption.textContent = 'Focused on India'; showIndiaOverlay(); }, zoomDuration + 90);
    }

    function showIndiaOverlay(){
      // reveal the full-screen image
      indiaOverlay.classList.add('visible');
      // optionally stop animating globe to save CPU (uncomment if desired)
      // cancelAnimationFrame(animationId);
    }

    function animate(now){
      drawStars(now || performance.now());
      animationId = requestAnimationFrame(animate);
      if (!globeMesh){ if(renderer) renderer.render(scene,camera); return; }

      if (phase === 0){
        globeMesh.rotation.y += autoRotateSpeed;
        globeMesh.rotation.x += Math.sin(performance.now()*0.0002)*0.0002;
        autoRotateSpeed *= rotationDamping;
      } else if (phase === 1){
        const t = Math.min(1,(performance.now()-focusStart)/focusDuration); const s = t*t*(3-2*t);
        globeMesh.rotation.x = startRot.x + (targetRot.x - startRot.x)*s;
        globeMesh.rotation.y = startRot.y + (targetRot.y - startRot.y)*s;
        caption.textContent = 'Focusing on India…';
      } else if (phase === 2){
        const t = Math.min(1,(performance.now()-zoomStart)/zoomDuration); const s = t*(2-t);
        camera.position.z = startCamZ + (targetCamZ - startCamZ)*s;
        globeMesh.rotation.x = targetRot.x * (0.98 + 0.02*s);
        globeMesh.rotation.y = targetRot.y * (1 + 0.01*(1-s));
        caption.textContent = 'Zooming in…';
      } else {
        globeMesh.rotation.y += 0.0006;
      }

      if (renderer) renderer.render(scene,camera);
    }

    // resize handler
    function onWindowResize(){
      width = window.innerWidth; height = window.innerHeight;
      if (renderer && camera){ camera.aspect = width/height; camera.updateProjectionMatrix(); renderer.setSize(width,height); }
      starCanvas.style.width = window.innerWidth + 'px';
      starCanvas.style.height = window.innerHeight + 'px';
      resizeStars();
    }

    // navigate back on scroll up (same behavior as before)
    let backNavigated = false;
    const UP_THRESHOLD = -40;
    window.addEventListener('wheel', (e)=>{ if (backNavigated) return; if (e.deltaY < UP_THRESHOLD){ backNavigated=true; setTimeout(()=>{ location.href='index.html'; }, 80); } }, {passive:true});
    let tStartY = null;
    window.addEventListener('touchstart', (e)=>{ if(e.touches && e.touches[0]) tStartY = e.touches[0].clientY; }, {passive:true});
    window.addEventListener('touchend', (e)=>{ if(backNavigated) return; if(!tStartY) return; const endY = (e.changedTouches && e.changedTouches[0]) ? e.changedTouches[0].clientY : null; if(endY===null){ tStartY=null; return; } const diff = endY - tStartY; if(diff>60){ backNavigated=true; location.href='index.html'; } tStartY=null; }, {passive:true});

    // start everything
    function start(){
      starCanvas.style.width = window.innerWidth + 'px';
      starCanvas.style.height = window.innerHeight + 'px';
      resizeStars();
      initThree();
      attemptTextureLoad();
      animate();
      window.addEventListener('resize', onWindowResize);
    }

    start();

    // cleanup
    window.addEventListener('beforeunload', ()=>{ cancelAnimationFrame(animationId); if(renderer) renderer.dispose && renderer.dispose(); });
  })();
  </script>
</body>
</html>
